Общая информация
-----------------

Создать текстовой файл, например script.edcl, в шапке (опционально)
указать путь к интерпретатору edcltool. 

Например: 
#!/usr/local/bin/edcltool

Поместить в этот файл команды. Для исполнения код используется интерпретатор языка 
lua, все стандартные библиотеки доступны.

Запускать можно напрямую edcl сценарий, либо вручную: 
edcltool -f имя_сценария.edcl 

Непосредственно указать сетевой интерфейс можно так:

edcltool -f имя_сценария.edcl -i eth1


Библиотека для обновления ПО 
----------------------------

Для подключения библиотеки в edcl сценарии: 

fw = require "fw"

Доступные функции:

fw.run_code(file, slavemode)

Загружает бинарный файл в накристальное ОЗУ и передает туда управление.
Файл загружается по адресу 0x00100010
TEXT_BASE должен быть      0x00100014 


slavemode - опционально устанавливает маркер для запуска загрузчика в slave режиме для обновления ПО.
Все нижеприведенные функции библиотеки взаимодействуют с загрузчиком запущенном в slave режиме, 
потому вызов этой функции должен предшествовать всем остальным командам. 

fw.mboot_cmd(cmd)

Запуск команды в командной строке загрузчика. 

fw.mboot_cmd_list(cmds)

Запуск последовательности команд в командной строке загрузчика. 

fw.write_bootloader(file)

Записывает загрузчик в соответсвующую область nand памяти из файла.
Образ загрузчика должен содержать валидную md5 чексумму, и, 
если это установлено в OTP - быть зашифрован.
При этом производится очистка переменных окружения загрузчика

fw.flash_part(part, file, withoob)

Перезаписывает mtd раздел part содержимым файла file. 
withoob означает, что образ содержит так же oob данные.

fw.partition(tbl)

Задает таблицу mtd разделов, и записывает ее окружение. 
Таблица задается в формате нижеследующей таблицы:
tbl = {
   { "kernel", 4*1024*1024 },  -- 4 мегабайта
   { "rootfs", 128*1024*1024 },  -- 128 мегабайт
   { "media",  "-"} -- все оставшееся место на NAND
}

Без задания таблицы разделов по умолчанию доступны только 
разделы boot и env. В slave режиме загрузка таблица разделов
не загружается из сохраненных в NAND переменных окружения.

Библиотека для работы с ядром nmc
---------------------------------

Для подключения библиотеки в edcl сценарии: 

nmc = require "nmc"

nmc.upload(offset, filename)

Загружает необходимые секции из elf (abs) файла в память. 
К полю sh_addr в заголовке каждой секции прибавляется offset.  

nmc.reset() 

Софт-ресет nmc ядра. 

nmc.run()

Запуск nmc ядра на исполнение кода.  


Низкоуровневые функции работы с edcl
-------------------------------------

Для работы с edcl доступны следующие функции: 

edcl_init(); 

Инициализация edcl и установление соединения с платой. Вызов этой функции должен предшествовать всем остальным вызовам.

edcl_write(type, address, value)

Запись памяти через edcl. type определяет режим записи, address - начальный адрес для записи. value - значение. Ограничения на value определяется типом записи. 
Доступно 4 режима записи: 

type = 1
Запись одного байта по адресу. 

Пример: 
-- Записать 1 байт (0x34) в 0x10000 
edcl_write(1 , 0x10000 , 0x34);
-- или
edcl_write(1 , 0x10000 , 52);

type = 2, записать число из двух байт, порядок little endian в адрес памяти
Пример:
edcl_write(2,0x10000,0x3432);

type = 4, записать 4 байта (little endian) в адрес памяти 
Пример:
edcl_write(4,0x10000,0x3432deaf);

type = 0, записать последовательность байт в адрес памяти. 
value при этом должно быть СТРОКОЙ, представляющей последовательность байт. 
Пример: 
edcl_write(0 , 0x10000 , "DEADBEEF0000FFFE");


edcl_writestring(addr, "string");

Запись С строки вместе с терминирующим 0x00 байтом по адресу в памяти. 

Пример: 
edcl_writestring(0 , 0x10000 , "Hello, world");


Аналогично реализовано чтение значений из памяти. 
value = edcl_read(type,address);

Поддерживае типы: 1 2 и 4, аналогично edcl_write

Примеры:
a = edcl_read(1,0x40000000);
b = edcl_read(2,0x40000004);
c = edcl_read(4,0x40000000);
print(a..b..c);


Так же можно ожидать появления числа в памяти при помощи edcl_wait.
Поддерживаемые типы: 1 2 4 
edcl_wait(type, address, value);

Пример: 
-- Ожидать появления байта 0x32 в памяти по адресу 0x1000.
edcl_wait(1,0x1000,0x32);

Или ожидать пока значение в памяти изменится. 

Пример: 
-- Ожидать когда байт в памяти по адресу 0x1000 будет != 0x32.
edcl_nwait(1,0x1000,0x32);

Для изменения интервала опроса памяти можно воспользоваться функцией ecl_poll_interval

-- Установка частоты опроса регистров для edcl_wait и edcl_nwait
-- Значение задается в микросекундах
edcl_poll_interval(100000);


Снятие дампа памяти в файл:
edcl_download(addr, filename, len);
Пример: 
-- Снятие дампа памяти
--- len=0x40000
--- edcl_download(0x1000, "/tmp/dump.bin", len);

Загрузка файла в память по адресу
n = edcl_upload(addr, filename);
Пример:
edcl_upload(0x40000000, "/etc/resolv.conf");


